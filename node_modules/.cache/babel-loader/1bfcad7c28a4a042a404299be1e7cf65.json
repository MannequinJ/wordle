{"ast":null,"code":"import ACTIONS from \"../Constants/ACTIONS\";\nimport { nanoid } from \"nanoid\";\nimport EMPTY_CHAR from \"../Constants/EMPTY_CHAR\";\nimport charCounter from \"./charCounter\";\n\nconst reducer = (state, action) => {\n  let currentWord;\n  let currentWordsArr;\n  let currentWordFilled;\n\n  switch (action.type) {\n    case ACTIONS.KEY_PRESS:\n      const currentChar = {\n        id: nanoid(),\n        text: action.payload.toUpperCase(),\n        status: \"\"\n      };\n      currentWord = [...state.currentWord, currentChar];\n      currentWordsArr = [...state.wordsArr];\n      currentWordFilled = [...currentWord];\n\n      for (let i = currentWord.length; i < 5; i++) {\n        currentWordFilled.push(EMPTY_CHAR);\n      }\n\n      currentWordsArr.splice(state.currentRow, 1, currentWordFilled);\n\n      if (state.currentWord.length < 5 && state.currentRow < 6) {\n        return { ...state,\n          currentWord: currentWord,\n          wordsArr: currentWordsArr,\n          currentCharIndex: state.currentCharIndex + 1\n        };\n      } else {\n        return state;\n      }\n\n    case ACTIONS.DELETE_CHAR:\n      // const currentWord = [...state.currentWord];\n      // console.log(state.currentCharIndex);\n      currentWordsArr = [...state.wordsArr];\n      currentWord = [...currentWordsArr[state.currentRow]];\n      currentWord.splice(state.currentCharIndex, 1, EMPTY_CHAR);\n      currentWordsArr.splice(state.currentRow, 1, currentWord);\n      return { ...state,\n        currentWord: state.currentWord.slice(0, -1),\n        wordsArr: currentWordsArr,\n        currentCharIndex: state.currentCharIndex - 1\n      };\n\n    case ACTIONS.CONFIRM_WORD:\n      ////////////// if answerWord have the same char already in right spot (take his id) and there is no more this chars break and return\n      let message; // &&\n\n      const mysteryWordCharsNumber = charCounter(state.mysteryWord.join(\"\"));\n\n      if (state.currentWord.length === 5 && state.wordsArr.length <= 6) {\n        const newCurrentWord = state.currentWord.map((char, i) => {\n          let status;\n\n          for (let k = 0; k < state.mysteryWord.length; k++) {\n            if (char.text === state.mysteryWord[k] && i === k) {\n              mysteryWordCharsNumber[char.text] -= 1;\n              status = \"correct-spot\";\n              break;\n            } else if (char.text === state.mysteryWord[k] && i !== k && mysteryWordCharsNumber[char.text]) {\n              status = \"wrong-spot\"; // break;\n            }\n          }\n\n          status = !status ? \"wrong-char\" : status;\n          return { ...char,\n            status: status\n          };\n        });\n\n        if (newCurrentWord.every(char => char.status === \"correct-spot\")) {\n          console.log(123);\n          message = \"Good job!\";\n        } // console.log();\n        ////////////////\n\n\n        const newWordsArr = [...state.wordsArr];\n        newWordsArr.splice(state.currentRow, 1, newCurrentWord); ////////////////\n\n        return { ...state,\n          wordsArr: newWordsArr,\n          currentWord: [],\n          message: message,\n          currentCharIndex: -1,\n          currentRow: state.currentRow + 1\n        };\n      } else {\n        return { ...state,\n          errorMessage: \"Not enough letters\"\n        };\n      }\n\n    default:\n      return state;\n  }\n};\n\nexport default reducer;","map":{"version":3,"sources":["C:/Files/Course/react-wordle-copy/wordle-copy/src/Functions/reducer.js"],"names":["ACTIONS","nanoid","EMPTY_CHAR","charCounter","reducer","state","action","currentWord","currentWordsArr","currentWordFilled","type","KEY_PRESS","currentChar","id","text","payload","toUpperCase","status","wordsArr","i","length","push","splice","currentRow","currentCharIndex","DELETE_CHAR","slice","CONFIRM_WORD","message","mysteryWordCharsNumber","mysteryWord","join","newCurrentWord","map","char","k","every","console","log","newWordsArr","errorMessage"],"mappings":"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","sourcesContent":["import ACTIONS from \"../Constants/ACTIONS\";\r\nimport { nanoid } from \"nanoid\";\r\nimport EMPTY_CHAR from \"../Constants/EMPTY_CHAR\";\r\nimport charCounter from \"./charCounter\";\r\nconst reducer = (state, action) => {\r\n  let currentWord;\r\n  let currentWordsArr;\r\n  let currentWordFilled;\r\n  switch (action.type) {\r\n    case ACTIONS.KEY_PRESS:\r\n      const currentChar = {\r\n        id: nanoid(),\r\n        text: action.payload.toUpperCase(),\r\n        status: \"\",\r\n      };\r\n      currentWord = [...state.currentWord, currentChar];\r\n      currentWordsArr = [...state.wordsArr];\r\n      currentWordFilled = [...currentWord];\r\n      for (let i = currentWord.length; i < 5; i++) {\r\n        currentWordFilled.push(EMPTY_CHAR);\r\n      }\r\n      currentWordsArr.splice(state.currentRow, 1, currentWordFilled);\r\n      if (state.currentWord.length < 5 && state.currentRow < 6) {\r\n        return {\r\n          ...state,\r\n          currentWord: currentWord,\r\n          wordsArr: currentWordsArr,\r\n          currentCharIndex: state.currentCharIndex + 1,\r\n        };\r\n      } else {\r\n        return state;\r\n      }\r\n\r\n    case ACTIONS.DELETE_CHAR:\r\n      // const currentWord = [...state.currentWord];\r\n      // console.log(state.currentCharIndex);\r\n      currentWordsArr = [...state.wordsArr];\r\n      currentWord = [...currentWordsArr[state.currentRow]];\r\n      currentWord.splice(state.currentCharIndex, 1, EMPTY_CHAR);\r\n      currentWordsArr.splice(state.currentRow, 1, currentWord);\r\n      return {\r\n        ...state,\r\n        currentWord: state.currentWord.slice(0, -1),\r\n        wordsArr: currentWordsArr,\r\n        currentCharIndex: state.currentCharIndex - 1,\r\n      };\r\n    case ACTIONS.CONFIRM_WORD:\r\n      ////////////// if answerWord have the same char already in right spot (take his id) and there is no more this chars break and return\r\n      let message;\r\n      // &&\r\n      const mysteryWordCharsNumber = charCounter(state.mysteryWord.join(\"\"));\r\n      if (state.currentWord.length === 5 && state.wordsArr.length <= 6) {\r\n        const newCurrentWord = state.currentWord.map((char, i) => {\r\n          let status;\r\n          for (let k = 0; k < state.mysteryWord.length; k++) {\r\n            if (char.text === state.mysteryWord[k] && i === k) {\r\n              mysteryWordCharsNumber[char.text] -= 1;\r\n              status = \"correct-spot\";\r\n              break;\r\n            } else if (\r\n              char.text === state.mysteryWord[k] &&\r\n              i !== k &&\r\n              mysteryWordCharsNumber[char.text]\r\n            ) {\r\n              status = \"wrong-spot\";\r\n              // break;\r\n            }\r\n          }\r\n          status = !status ? \"wrong-char\" : status;\r\n          return {\r\n            ...char,\r\n            status: status,\r\n          };\r\n        });\r\n        if (newCurrentWord.every((char) => char.status === \"correct-spot\")) {\r\n          console.log(123);\r\n          message = \"Good job!\";\r\n        }\r\n        // console.log();\r\n        ////////////////\r\n        const newWordsArr = [...state.wordsArr];\r\n        newWordsArr.splice(state.currentRow, 1, newCurrentWord);\r\n        ////////////////\r\n        return {\r\n          ...state,\r\n          wordsArr: newWordsArr,\r\n          currentWord: [],\r\n          message: message,\r\n          currentCharIndex: -1,\r\n          currentRow: state.currentRow + 1,\r\n        };\r\n      } else {\r\n        return {\r\n          ...state,\r\n          errorMessage: \"Not enough letters\",\r\n        };\r\n      }\r\n    default:\r\n      return state;\r\n  }\r\n};\r\nexport default reducer;\r\n"]},"metadata":{},"sourceType":"module"}