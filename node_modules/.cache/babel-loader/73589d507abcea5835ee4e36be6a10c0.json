{"ast":null,"code":"import ACTIONS from \"../Constants/ACTIONS\";\nimport { nanoid } from \"nanoid\";\nimport EMPTY_CHAR from \"../Constants/EMPTY_CHAR\";\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case ACTIONS.KEY_PRESS:\n      const newChar = {\n        id: nanoid(),\n        text: action.payload.toUpperCase(),\n        status: \"\"\n      };\n      const currentWord = [...state.currentWord, newChar];\n      const wordsArr = [...state.wordsArr];\n      const currentWordFilled = [...currentWord];\n\n      for (let i = currentWord.length; i < 5; i++) {\n        currentWordFilled.push(EMPTY_CHAR);\n      }\n\n      wordsArr.splice(state.currentRow, 1, currentWordFilled);\n\n      if (state.currentWord.length < 5) {\n        return { ...state,\n          // currentChar: newChar,\n          currentWord: currentWord,\n          wordsArr: wordsArr\n        };\n      } else {\n        return { ...state // currentChar: { ...state.currentChar, text: action.payload },\n\n        };\n      }\n\n    case ACTIONS.DELETE_CHAR:\n      return { ...state,\n        currentWord: state.currentWord.slice(0, -1)\n      };\n\n    case ACTIONS.CONFIRM_WORD:\n      //////////////\n      let message;\n\n      if (state.currentWord.length === 5 && state.wordsArr.length <= 6) {\n        const newCurrentWord = state.currentWord.map((char, i) => {\n          let status;\n\n          for (let k = 0; k < state.mysteryWord.length; k++) {\n            if (char.text === state.mysteryWord[k] && i === k) {\n              status = \"correct-spot\";\n              break;\n            } else if (char.text === state.mysteryWord[k] && i !== k) {\n              status = \"wrong-spot\"; // break;\n            }\n          }\n\n          status = !status ? \"wrong-char\" : status;\n          return { ...char,\n            status: status\n          };\n        });\n\n        if (newCurrentWord.every(char => char.status === \"correct-spot\")) {\n          console.log(123);\n          message = \"Good job!\";\n        } // console.log();\n        ////////////////\n\n\n        const indexOfWordsArr = state.wordsArr.findIndex(arr => arr[0].id === \"\");\n        const newWordsArr = [...state.wordsArr];\n        newWordsArr.splice(+indexOfWordsArr, 1, newCurrentWord); ////////////////\n\n        return { ...state,\n          wordsArr: newWordsArr,\n          currentWord: [],\n          message: message,\n          currentRow: state.currentRow + 1\n        };\n      } else {\n        return { ...state,\n          errorMessage: \"Not enough letters\"\n        };\n      }\n\n    default:\n      return state;\n  }\n};\n\nexport default reducer;","map":{"version":3,"sources":["C:/Files/Course/react-wordle-copy/wordle-copy/src/Functions/reducer.js"],"names":["ACTIONS","nanoid","EMPTY_CHAR","reducer","state","action","type","KEY_PRESS","newChar","id","text","payload","toUpperCase","status","currentWord","wordsArr","currentWordFilled","i","length","push","splice","currentRow","DELETE_CHAR","slice","CONFIRM_WORD","message","newCurrentWord","map","char","k","mysteryWord","every","console","log","indexOfWordsArr","findIndex","arr","newWordsArr","errorMessage"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,sBAApB;AACA,SAASC,MAAT,QAAuB,QAAvB;AACA,OAAOC,UAAP,MAAuB,yBAAvB;;AACA,MAAMC,OAAO,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACjC,UAAQA,MAAM,CAACC,IAAf;AACE,SAAKN,OAAO,CAACO,SAAb;AACE,YAAMC,OAAO,GAAG;AACdC,QAAAA,EAAE,EAAER,MAAM,EADI;AAEdS,QAAAA,IAAI,EAAEL,MAAM,CAACM,OAAP,CAAeC,WAAf,EAFQ;AAGdC,QAAAA,MAAM,EAAE;AAHM,OAAhB;AAKA,YAAMC,WAAW,GAAG,CAAC,GAAGV,KAAK,CAACU,WAAV,EAAuBN,OAAvB,CAApB;AACA,YAAMO,QAAQ,GAAG,CAAC,GAAGX,KAAK,CAACW,QAAV,CAAjB;AACA,YAAMC,iBAAiB,GAAG,CAAC,GAAGF,WAAJ,CAA1B;;AACA,WAAK,IAAIG,CAAC,GAAGH,WAAW,CAACI,MAAzB,EAAiCD,CAAC,GAAG,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;AAC3CD,QAAAA,iBAAiB,CAACG,IAAlB,CAAuBjB,UAAvB;AACD;;AACDa,MAAAA,QAAQ,CAACK,MAAT,CAAgBhB,KAAK,CAACiB,UAAtB,EAAkC,CAAlC,EAAqCL,iBAArC;;AACA,UAAIZ,KAAK,CAACU,WAAN,CAAkBI,MAAlB,GAA2B,CAA/B,EAAkC;AAChC,eAAO,EACL,GAAGd,KADE;AAEL;AACAU,UAAAA,WAAW,EAAEA,WAHR;AAILC,UAAAA,QAAQ,EAAEA;AAJL,SAAP;AAMD,OAPD,MAOO;AACL,eAAO,EACL,GAAGX,KADE,CAEL;;AAFK,SAAP;AAID;;AACH,SAAKJ,OAAO,CAACsB,WAAb;AACE,aAAO,EACL,GAAGlB,KADE;AAELU,QAAAA,WAAW,EAAEV,KAAK,CAACU,WAAN,CAAkBS,KAAlB,CAAwB,CAAxB,EAA2B,CAAC,CAA5B;AAFR,OAAP;;AAIF,SAAKvB,OAAO,CAACwB,YAAb;AACE;AACA,UAAIC,OAAJ;;AACA,UAAIrB,KAAK,CAACU,WAAN,CAAkBI,MAAlB,KAA6B,CAA7B,IAAkCd,KAAK,CAACW,QAAN,CAAeG,MAAf,IAAyB,CAA/D,EAAkE;AAChE,cAAMQ,cAAc,GAAGtB,KAAK,CAACU,WAAN,CAAkBa,GAAlB,CAAsB,CAACC,IAAD,EAAOX,CAAP,KAAa;AACxD,cAAIJ,MAAJ;;AACA,eAAK,IAAIgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,KAAK,CAAC0B,WAAN,CAAkBZ,MAAtC,EAA8CW,CAAC,EAA/C,EAAmD;AACjD,gBAAID,IAAI,CAAClB,IAAL,KAAcN,KAAK,CAAC0B,WAAN,CAAkBD,CAAlB,CAAd,IAAsCZ,CAAC,KAAKY,CAAhD,EAAmD;AACjDhB,cAAAA,MAAM,GAAG,cAAT;AACA;AACD,aAHD,MAGO,IAAIe,IAAI,CAAClB,IAAL,KAAcN,KAAK,CAAC0B,WAAN,CAAkBD,CAAlB,CAAd,IAAsCZ,CAAC,KAAKY,CAAhD,EAAmD;AACxDhB,cAAAA,MAAM,GAAG,YAAT,CADwD,CAExD;AACD;AACF;;AACDA,UAAAA,MAAM,GAAG,CAACA,MAAD,GAAU,YAAV,GAAyBA,MAAlC;AACA,iBAAO,EACL,GAAGe,IADE;AAELf,YAAAA,MAAM,EAAEA;AAFH,WAAP;AAID,SAhBsB,CAAvB;;AAiBA,YAAIa,cAAc,CAACK,KAAf,CAAsBH,IAAD,IAAUA,IAAI,CAACf,MAAL,KAAgB,cAA/C,CAAJ,EAAoE;AAClEmB,UAAAA,OAAO,CAACC,GAAR,CAAY,GAAZ;AACAR,UAAAA,OAAO,GAAG,WAAV;AACD,SArB+D,CAsBhE;AACA;;;AACA,cAAMS,eAAe,GAAG9B,KAAK,CAACW,QAAN,CAAeoB,SAAf,CACrBC,GAAD,IAASA,GAAG,CAAC,CAAD,CAAH,CAAO3B,EAAP,KAAc,EADD,CAAxB;AAGA,cAAM4B,WAAW,GAAG,CAAC,GAAGjC,KAAK,CAACW,QAAV,CAApB;AACAsB,QAAAA,WAAW,CAACjB,MAAZ,CAAmB,CAACc,eAApB,EAAqC,CAArC,EAAwCR,cAAxC,EA5BgE,CA6BhE;;AACA,eAAO,EACL,GAAGtB,KADE;AAELW,UAAAA,QAAQ,EAAEsB,WAFL;AAGLvB,UAAAA,WAAW,EAAE,EAHR;AAILW,UAAAA,OAAO,EAAEA,OAJJ;AAKLJ,UAAAA,UAAU,EAAEjB,KAAK,CAACiB,UAAN,GAAmB;AAL1B,SAAP;AAOD,OArCD,MAqCO;AACL,eAAO,EACL,GAAGjB,KADE;AAELkC,UAAAA,YAAY,EAAE;AAFT,SAAP;AAID;;AACH;AACE,aAAOlC,KAAP;AA/EJ;AAiFD,CAlFD;;AAmFA,eAAeD,OAAf","sourcesContent":["import ACTIONS from \"../Constants/ACTIONS\";\r\nimport { nanoid } from \"nanoid\";\r\nimport EMPTY_CHAR from \"../Constants/EMPTY_CHAR\";\r\nconst reducer = (state, action) => {\r\n  switch (action.type) {\r\n    case ACTIONS.KEY_PRESS:\r\n      const newChar = {\r\n        id: nanoid(),\r\n        text: action.payload.toUpperCase(),\r\n        status: \"\",\r\n      };\r\n      const currentWord = [...state.currentWord, newChar];\r\n      const wordsArr = [...state.wordsArr];\r\n      const currentWordFilled = [...currentWord];\r\n      for (let i = currentWord.length; i < 5; i++) {\r\n        currentWordFilled.push(EMPTY_CHAR);\r\n      }\r\n      wordsArr.splice(state.currentRow, 1, currentWordFilled);\r\n      if (state.currentWord.length < 5) {\r\n        return {\r\n          ...state,\r\n          // currentChar: newChar,\r\n          currentWord: currentWord,\r\n          wordsArr: wordsArr,\r\n        };\r\n      } else {\r\n        return {\r\n          ...state,\r\n          // currentChar: { ...state.currentChar, text: action.payload },\r\n        };\r\n      }\r\n    case ACTIONS.DELETE_CHAR:\r\n      return {\r\n        ...state,\r\n        currentWord: state.currentWord.slice(0, -1),\r\n      };\r\n    case ACTIONS.CONFIRM_WORD:\r\n      //////////////\r\n      let message;\r\n      if (state.currentWord.length === 5 && state.wordsArr.length <= 6) {\r\n        const newCurrentWord = state.currentWord.map((char, i) => {\r\n          let status;\r\n          for (let k = 0; k < state.mysteryWord.length; k++) {\r\n            if (char.text === state.mysteryWord[k] && i === k) {\r\n              status = \"correct-spot\";\r\n              break;\r\n            } else if (char.text === state.mysteryWord[k] && i !== k) {\r\n              status = \"wrong-spot\";\r\n              // break;\r\n            }\r\n          }\r\n          status = !status ? \"wrong-char\" : status;\r\n          return {\r\n            ...char,\r\n            status: status,\r\n          };\r\n        });\r\n        if (newCurrentWord.every((char) => char.status === \"correct-spot\")) {\r\n          console.log(123);\r\n          message = \"Good job!\";\r\n        }\r\n        // console.log();\r\n        ////////////////\r\n        const indexOfWordsArr = state.wordsArr.findIndex(\r\n          (arr) => arr[0].id === \"\"\r\n        );\r\n        const newWordsArr = [...state.wordsArr];\r\n        newWordsArr.splice(+indexOfWordsArr, 1, newCurrentWord);\r\n        ////////////////\r\n        return {\r\n          ...state,\r\n          wordsArr: newWordsArr,\r\n          currentWord: [],\r\n          message: message,\r\n          currentRow: state.currentRow + 1,\r\n        };\r\n      } else {\r\n        return {\r\n          ...state,\r\n          errorMessage: \"Not enough letters\",\r\n        };\r\n      }\r\n    default:\r\n      return state;\r\n  }\r\n};\r\nexport default reducer;\r\n"]},"metadata":{},"sourceType":"module"}